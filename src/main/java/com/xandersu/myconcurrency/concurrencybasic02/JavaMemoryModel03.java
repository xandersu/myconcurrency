package com.xandersu.myconcurrency.concurrencybasic02;

/**
 * @Author: suxun
 * @Date: 2018/12/10 22:03
 * @Description: JAVA内存模型 JMM  java memory model
 * 一种规范,规范了jvm和计算机内存是如何协同工作，
 * 规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步的访问共享变量
 * ·
 * 堆heap：运行时数据去，垃圾回收，动态分配内存大小，生存期不必实现告诉编译器，存取速度慢
 * 栈stack：比堆快，仅次于寄存器，栈数据可以共享，栈内的数据大小和生存期是确定的，
 * 栈主要存放基本类型变量，int，long，堆栈句柄
 * ·
 * 同步八种操作
 * 1、lock锁定：作用于主内存的变量，把一个变量标示为一条线程独占的状态
 * 2、unlock解锁：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他其他线程锁定
 * 3、read读取：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
 * 4、load载入：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
 * 5、use使用：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
 * 6、assign赋值：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
 * 7、store存储：作用于工作内存的变量，把工作内存中的一个变量的值传送给主内存中，以便随后的write操作
 * 8、write写入：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中
 * ·
 * 同步规则
 * 1、如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，
 * 如果把变量从工作内存中同步回主内存中，就要按顺序的执行store和write操作。
 * 但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
 * 2、不允许read和load、store和write操作之一单独出现
 * 3、不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须同步到主内存中
 * 4、不允许一个线程无原因的（没有发生任何assign操作）把数据从工作内存同步到主内存中
 * 5、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。
 * 即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
 * 6、一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，
 * 多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
 * 7、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行
 * load或assign操作初始化变量的值。
 * 8、如果一个操作事先没有被lock操作锁定，则不允许对他执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
 * 9、对一个变量执行unlock操作之前，必须把此变量同步到主内存中（执行store和write操作）
 * -                  -> 工作内存 -> java线程
 * 主内存 -> save/load -> 工作内存 -> java线程
 * -                 -> 工作内存 -> java线程
 * lock   - read    ->  load    ->  use
 * unlock - write   <-  store   <- assign
 */
public interface JavaMemoryModel03 {
}
